# 折叠表达式

折叠表达式（Fold Expressions ）
C++17中引入的，目的：计算某个值，(表达式的结果当然是一个值)
该值的特殊性在于：他与所有可变参有关，而不是与单独的某个可变参有关。需要所有可变参都参与计算，才能求出该值

折叠表达式 有四种格式，一元左折，一元右折，二元左折，二元右折
注意每一种格式的折叠表达式都需要用圆括号扩住

> 左折：就是参数从左侧开始计算
> 右折：参数从右侧开始计算



## 一元左折（unary left fold）

格式：(... 运算符  一包参数);

计算过程：

(((参数1  运算符 参数2) 运算符 参数3)...运算符 参数n);

```c++
namespace _nmsp1
{
    template<typename... T>
    auto add_args(T... args)
    {
        return (... +args);
        // 注意这里的()不能省略，否者会编译错误
    }
    
    void func()
    {
        std::cout << add_args(12, 42, 352, 354, 23) << std::endl;   // 783
        
    }
}
```



## 一元右折 （unary right fold）


格式：(一包参数 运算符 ...);

运算过程：

(参数1 运算符 (...(参数n-1 运算符 参数 n)));

```c++
namespace _nmsp2
{
    template<typename... T>
    auto add_args(T... args)
    {
        return (args + ...);
        // 注意这里的()不能省略，否者会编译错误
    }
    
    template<typename... U>
    auto sub_args(U... args)
    {
        return (args - ...);
    }
    
    void func()
    {
        std::cout << add_args(12, 42, 352, 354, 23) << std::endl;   // 783
        
        std::cout << sub_args(1, 10, 100, 1000) << std::endl;       // -909
        // 100 - 1000 = -900
        // 10 - (-900) = 910
        // 1 - 910 = -909
        
    }
}
```



## 二元左折（binary left fold）

**格式：**
(init 运算符 ... 运算符 一包参数);

**计算过程**
(((init 运算符 参数1) 运算符 参数2)...运算符 参数n);

**init 表示啥？**
表示一个初始的东西，他可能是一个值，也可能是一个其他东西
注意：二元左折里两个运算符必须一样，如果不一样则会编译报错

```c++
namespace _nmsp3
{
    template<typename... T>
    auto sub_val_left(T... args)
    {
        // return (1000 - ... + args);
        // 注意：二元左折里两个运算符必须一样，如果不一样则会编译报错
        // 
        return (1000 - ... - args);
    }
    
    template<typename... T>
    void print_val_left(T... args)
    {
        (cout<< ... << args );
        
        // 这里就是 起始值 cout 和 << 和 参数1 进行运算（输出参数1，返回 cout）
        // 然后返回的 cout 再和 << 和 参数2 进行运算 。。。。。。。。
        // cout << 1000 这个的执行结果是 ：屏幕上输出 1000  ，
        // 然后：一个基本知识：cout 他是一个对象，他的<<运算符执行之后，返回的还是一个 cout 对象 
        // print_val_left(1000, 1000, 100, 10, 1);
        // 所以对于上面这个行代码，他的执行逻辑就是
        // (((((cout << 10000 ) << 1000) << 100 ) << 10 ) << 1)
        // 执行了5次cout<<，然后依次把参数包了的参数打印出来
    }
    
    void func()
    {
        std::cout << sub_val_left(100, 10 , 1) << std::endl;
        // (((1000 - 100)-10)-1)  = 889;
        
        print_val_left(1000, 1000, 100, 10, 1);
        // 10001000100101
    }
}
```



## 二元右折（binary right fold）

**格式：**
(一包参数 运算符 ... 运算符 init);

**计算过程：**
(参数1 运算符 (...(参数n-1 运算符 ( 参数n 运算符 init))));  

**init 表示啥？**
表示一个初始的东西，他可能是一个值，也可能是一个其他东西

注意：二元右折里两个运算符必须一样，如果不一样则会编译报错

```c++
namespace _nmsp4
{
    template<typename... T>
    auto sub_val_right(T... args)
    {
        return (args - ... - 10000);
    }
    
    // 貌似这种 cout 不能像二元左折 一样进行使用
    // template<typename... U>
    // void print_val_right(U... args)
    // {
    //     (args << ... << cout );
    // }
    
    
    void func()
    {
        std::cout << sub_val_right(10000, 1000, 100, 10, 1) << std::endl;   // -909
        // (10000 - ( 1000 - (100 - (10 - (1 - 10000))))) = -909
        
        // print_val_right(10000, 1000, 100, 10, 1);
    }
}

```



# 可变参表达式

std::cout << print_result(2 * args...) << std::endl;

std::cout << print_result(args * 2 ...) << std::endl; 
这种写法也OK（但是...如果不和args紧紧挨着，中间就必须有空格）
注意这里的写法，这里就相当于是把参数包进行了 *2 处理，参数值翻倍
所以，如果需要对参数包进行特殊处理，就需要项这种，新引入一个可变参数模板
        

2 * args... 这个就是一个可变参表达式
等价于(1 * 参数1, 2* 参数2 , 2* 参数3,.... 2* 参数n)

### 一些特殊写法可行性：

​        (2*args); 这种写法不行 （args后面没有...也不行）

​        (args... *2);    这种也不行（args放前面也不行）

​        (args * 2 ...);  这种可以（...在后面，而且不去atgs紧接着也是可以的）但是...如果不和args紧紧挨着，中间就必须有空格

​        ((args * 2) ...); 这种也可以 

​        (args + args...); 这种也是可以的，一个待...，一个不带 

​        (args... + args...); 或者 (args ... + args...); 或者 (args... + args);  这些又都不可以



```c++
namespace _nmsp5
{
    template<typename... T>
    auto print_result(T const&...  args)
    {
        (cout << ... << args) << "结束" << endl;
        return (... + args);
    }
    
    template<typename... T>
    void calcNum(T const&... args)
    {
        std::cout << print_result(2 * args...) << std::endl;
        // std::cout << print_result(args * 2 ...) << std::endl; 
        // 这种写法也OK（但是...如果不和args紧紧挨着，中间就必须有空格）
        // 注意这里的写法，这里就相当于是把参数包进行了 *2 处理，参数值翻倍
        // 所以，如果需要对参数包进行特殊处理，就需要项这种，新引入一个可变参数模板
        // 2 * args... 这个就是一个可变参表达式
        // 等价于(1 * 参数1, 2* 参数2 , 2* 参数3,.... 2* 参数n)
        // (2*args); 这种写法不行 （args后面没有...也不行）
        // (args... *2);    这种也不行（args放前面也不行）
        // (args * 2 ...);  这种可以（...在后面，而且不去atgs紧接着也是可以的）但是...如果不和args紧紧挨着，中间就必须有空格
        // ((args * 2) ...); 这种也可以 
        // (args + args...); 这种也是可以的，一个待...，一个不带 
        // (args... + args...); 或者 (args ... + args...); 或者 (args... + args);
        // 这些又都不可以
    }
    
    void func()
    {
        std::cout << print_result(1, 10, 100, 1000, 10000) << std::endl;
        // 110100100010000结束
        // 11111
        
        calcNum(1, 10, 100, 1000, 10000);
        // 220200200020000结束
        // 22222
        
    }
}
```



在C++中，`operator`关键字主要用于重载操作符和定义转换操作符。通过重载操作符，可以自定义类的行为，使其支持标准的C++操作符。以下是对C++中`operator`关键字的全面解释，包括常见用途和示例。

### 1. 操作符重载

操作符重载允许你为自定义类型定义标准操作符的行为。常见的操作符包括算术操作符、关系操作符、赋值操作符等。

#### 1.1 算术操作符
- **加法 (`+`)**:
  
  ```cpp
  class MyNumber {
  public:
      int value;
      MyNumber(int v) : value(v) {}
      
      MyNumber operator+(const MyNumber& other) const {
          return MyNumber(value + other.value);
      }
  };
  ```
  
- **减法 (`-`)**:
  ```cpp
  MyNumber operator-(const MyNumber& other) const {
      return MyNumber(value - other.value);
  }
  ```

#### 1.2 关系操作符
- **等于 (`==`)**:
  ```cpp
  bool operator==(const MyNumber& other) const {
      return value == other.value;
  }
  ```

- **不等于 (`!=`)**:
  ```cpp
  bool operator!=(const MyNumber& other) const {
      return !(*this == other);
  }
  ```

#### 1.3 赋值操作符
- **赋值 (`=`)**:
  ```cpp
  MyNumber& operator=(const MyNumber& other) {
      if (this != &other) {
          value = other.value;
      }
      return *this;
  }
  ```

#### 1.4 自增和自减操作符
- **前缀自增 (`++`)**:
  ```cpp
  MyNumber& operator++() {
      ++value;
      return *this;
  }
  ```

- **后缀自增 (`++`)**:
  ```cpp
  MyNumber operator++(int) {
      MyNumber temp = *this;
      ++(*this);
      return temp;
  }
  ```

#### 1.5 输入/输出操作符
- **输入 (`>>`)**:
  ```cpp
  friend std::istream& operator>>(std::istream& in, MyNumber& num) {
      in >> num.value;
      return in;
  }
  ```

- **输出 (`<<`)**:
  ```cpp
  friend std::ostream& operator<<(std::ostream& out, const MyNumber& num) {
      out << num.value;
      return out;
  }
  ```

### 2. 转换操作符

转换操作符允许你定义一个类如何隐式转换为其他类型。

#### 2.1 隐式转换
- **转换为 `int`**:
  ```cpp
  operator int() const {
      return value;
  }
  ```

- **转换为 `bool`**:
  ```cpp
  operator bool() const {
      return value != 0;
  }
  ```

### 3. 函数调用操作符 (`operator()`)

函数调用操作符允许你将对象当作函数来调用。

```cpp
class MyFunction {
public:
    int operator()(int x, int y) {
        return x + y;
    }
};

int main() {
    MyFunction func;
    int result = func(3, 4); // 调用 operator()(3, 4)
    std::cout << "Result: " << result << std::endl; // 输出: Result: 7
    return 0;
}
```

### 4. 下标操作符 (`operator[]`)

下标操作符允许你通过索引访问对象的内部数据。

```cpp
class MyArray {
private:
    int data[10];
public:
    int& operator[](int index) {
        return data[index];
    }

    const int& operator[](int index) const {
        return data[index];
    }
};

int main() {
    MyArray arr;
    arr[0] = 10;
    std::cout << "arr[0]: " << arr[0] << std::endl; // 输出: arr[0]: 10
    return 0;
}
```

### 5. 成员指针操作符 (`operator->`)

成员指针操作符允许你通过指针访问对象的成员。

```cpp
class MyClass {
public:
    int value;
};

class MyPointer {
private:
    MyClass* ptr;
public:
    MyPointer(MyClass* p) : ptr(p) {}

    MyClass* operator->() {
        return ptr;
    }
};

int main() {
    MyClass obj;
    obj.value = 10;
    MyPointer ptr(&obj);
    std::cout << "ptr->value: " << ptr->value << std::endl; // 输出: ptr->value: 10
    return 0;
}
```

### 6. 删除操作符 (`operator delete` 和 `operator new`)

删除和分配操作符允许你自定义内存管理。

```cpp
class MyObject {
public:
    void* operator new(size_t size) {
        std::cout << "Custom new called, allocating " << size << " bytes\n";
        return ::operator new(size);
    }

    void operator delete(void* ptr) noexcept {
        std::cout << "Custom delete called\n";
        ::operator delete(ptr);
    }
};

int main() {
    MyObject* obj = new MyObject();
    delete obj;
    return 0;
}
```

### 总结

`operator`关键字在C++中主要用于操作符重载和转换操作符的定义。通过重载操作符，可以使自定义类型的行为更加自然和直观。常见的操作符包括算术操作符、关系操作符、赋值操作符、输入/输出操作符、函数调用操作符、下标操作符、成员指针操作符和内存管理操作符。希望这些示例能帮助你更好地理解和使用C++中的`operator`关键字。



事情是这样的，在我学习Hazel游戏引擎的过程中，发现他在关于组件复制这里，有一个模板函数，出现了一个乍一看很晦涩的奇怪用法，后来细致研究了一下，发现是之前学习的关于C++17里的折叠表达式的一个很好的实践例子，所以很想和各位分享一下，于是便有了这个视频。

首先，我们看Hazel源码里这个函数CopyComponent，它是一个函数模板，严格来讲是一个可变参的函数模板，字面意思来看，这个函数的用途就是用于复制组件内容。它的模板参数部分，也就是这个模板的变参部分，是组件的类型（比如摄像机组件，变换组件，ID组件，标签名组件等等），用来标识你调用这个函数时，想要复制的组件内容。然后是函数模板的实参部分，一个源entity（实体）的注册器，一个目标entity的注册器，还有一个哈希表，键为UUID（int64整形数)，key为entity实例。（Hazel引擎用的是ECS（Entity-Component-System）架构来管理引擎里的实体和组件对象，这部分不是这个视频的核心，有兴趣的可以自行了解，这里就只是简单介绍一下）。

然后便是这个模板的函数体部分，第一眼，我们看到的是一个lambda表达式，在这个lambda里，做的事情就是将源实体里的组件添加或者覆盖到目标实体中，这部分有个很关键的信息，就是这个需要拷贝的组件类型信息，也就是我们上面提到的这个可变参函数模板的模板类型参数部分。正是有这个类型信息，我们才知道我们在复制实体的时候，需要添加或者覆盖哪些组件。

然后函数的作用讲完，接下来就是最关键的一个部分，也是最开始让我疑惑的一点，我们看到，整个lambda是使用圆括号括起来的，而且，该lambda是立即执行函数（也就是该lambda在尾部添加了执行表达式（）)，然后后半部分还有一个逗号和一个参数列表...。

看完这个函数体，我立马回想起之前学过的关于C++17里的折叠表达式的用法，也是一包参数加运算符加点点点然后整体括起来的形式。果然，翻看笔记，我确定了这个函数模板用的就是折叠表达式里的一元右折语法。

为了方便理解后续内容，这里简单介绍一下折叠表达式，折叠表达式是C++17标准引入的一个新概念，它往往出现在可变参模板相关的计算中，比如，举一个简单例子，现在我们需要实现一个加法函数，用于计算参数相加结果，但是，这里，参数数量是不固定的（难度加大点，甚至参数类型也是不固定的）。那我们先想一想计算过程，先将第一个参数和第二个参数相加，然后，将计算结果继续和第三个参数相加，以此类推，直到所有参数计算完毕。此前要实现这样的计算，我们只能通过递归函数调用来实现，现在，C++17里直接一行代码调用就能实现这样的计算，那便是折叠表达式。写作 (...+args)。这个代码展开的含义或者计算计算过程就是上面我说的那个过程。不过在C++17里，这种参数从前往后计算的方式，我们称为一元左折，这里的“一元”指的是每次操作只涉及一个额外的参数（只接受一个参数），即当前序列中的元素，左折指的就是参数从左侧开始计算。

那同样的，对于前面那个加法计算，我们自然也可以从参数列表的最后开始往前计算，效果也是一样的，写作 （args + ...），那这种形式的折叠表达式，就被成为一元右折。右折就是指参数从右开始计算。

讲完一元折叠，实际上也就能帮助我们理解Hazel里的那个函数模板了，不过这里还是把二元折叠相关的内容页补充完整吧。

二元左折涉及到两个参数的操作。除了一个累积结果外，每次迭代还会涉及到两个操作对象，这两个对象可以是类型、值或其他任何可以通过模板参数传递的东西。二元左折通常用于更复杂的操作。这里举3个例子：

这里，我们有这样一个计算需求，要求计算1000减去一包参数的结果，注意，这里引入了一个初始值，1000，那么这里就不能再用此前的一元折叠的思维来对其进行计算，因为一元折叠是计算过程是只与传入的可变参数相关的，在不引入额外参数的情况，显然，我们是不能直接使用一元折叠来计算的。那这里就需要用到二元折叠。很简单，我们先考虑计算过程，用1000减去第一个参数，然后将结果继续减去第二个参数，以此类推，最终得到我们要的结果。用二元表达式写为 （1000 - ... - args)。注意这里，二元折叠里两个运算符必须保持一样，否则编译报错。上述这种形式的表达式，我们成为二元左折，“二元”指的是折叠表达式中使用的操作符是二元操作符，即该操作符接受两个参数，左折，从可变参列表左边开始计算。

这里大家可能会对一元和二元的概念有点混淆，认为好像从计算过程来说，他两貌似是一样的，其实，不是这样的，比如就拿加法来说，一元折叠表达式使用一元操作符，通常用于简单地遍历参数包中的每个元素。一元操作符只接受一个参数，因此一元折叠表达式不能直接用于计算加法和值。上面我们写的函数模板其实是有缺陷的，因为他没有显式的初始值，在参数包为空的时候，会出现编译错误。虽然一元操作符不能直接用于加法，但我们可以通过逗号操作符 `,` 来实现类似的效果。对比起来，二元折叠表达式用二元操作符，可以直接用于计算加法和值。二元操作符接受两个参数，因此二元折叠表达式可以自然地实现累积操作。

然后我们继续举一个例子，该函数模板用于打印传入的参数包。代码如下：

对于这个二元折叠表达式，它的初始值就是这里的cout。

然后我们再看一个字符串拼接的例子，这里初始值 `init` 是 `"Hello"`。参数包 `args...` 包含 `" "`, `"World"`, 和 `"!"`。操作符 `+` 用于连接字符串。

同样，对于二元折叠也有左折和右折叠之分，他们的格式我贴屏幕上了。

OK，终于我们讲完了折叠表达式，现在，我们回到CopyComponent这个函数模板，是不是就能很容易看出，它这里其实就是一个一元右折表达式展开形参包的计算用法，只不过，它这里运算符是用的一个lambda表达式作为运算符，lambda在现代C++中真的越来越好用，用的地方也越来越多了。

它这里是匿名的lambda表达式，而且，也是一个普通的lambda，对于如何展开参数包可能还是有点不太明显，我在自己的项目代码里，改写了这部分，来看一下我的。顺便说一下，它这里这个一元折叠表达式，因为显式调用的时候没有传递模板参数，所以在C++20里编译会报错 折叠表达式没有正确展开参数包。我不确定C++17是否是正常的，我没有测试，但是如果你用的是C++20直接用它这个代码编译是会报错的。

在我的项目代码里，首先我将这个匿名的lambda表达式改为一个命名的lambda表达式，同时为了更直观的显示出形参包的类型参数的解包过程（即一元折叠表达式是如何解包可变形参包的），我将lambda改为使用lambda模板，因为该lambda模板只是需要其模板类型信息，而不需要其类型实例，所以只有模板类型参数，而不需要在lambda表达式的参数列表里添加形参。

然后就是将这个lambda表达式作为运算符，结合逗号运算符使用一元折叠表达式依次对每种组件类型（可变类型模板参数）进行组件复制。

正常来说，在这里我们直接 (process_type<Comp>(), ...) 就行，对吗？实际不对，这是因为 C++ 标准对模板参数的解析有一些特定的要求，特别是在涉及依赖名称（dependent name）时。总而言之就是，如果直接调用，编译器可能不会知道这个lambda是一个模板，所以需要使用.template显式告知编译器这是一个模板，其次，需要使用operator()来进行模板调用并传递类型参数Comp。

当然，这里我们也同样可以用匿名lambda，也没什么影响，效果都是一样的。

至此，我们就明白Hazel这里的组件拷贝的代码逻辑，也进一步学到了折叠表达式在实际项目里的可能用法。我对C++的一些模板语法的看法就是，可以不会写，但是需要会读。

