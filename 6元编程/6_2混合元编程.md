# 混合元编程

- 1）程序员写出一段元编程代码
- 2）编译器根据这段代码编译（生成）一段新代码，实现程序真正功能的是这段生成的新代码
- 3）编译器会对这段新代码进行编译，产生出最终的可执行程序

混合元编程可以看成是运行时c++代码生成器


## 常规的计算点积范例

- 1）数组a有3个元素， a[0], a[1], a[2], 值分别是 1， 2， 3
- 2）数组b有3个元素， b[0], b[1], b[2], 值分别是 4， 5， 6

a和b的点积就是， a[0] * b[0] + a[1] * b[1] + a[2] * b[2] = 32

```c++
namespace _nmsp2
{
    // T 是数组元素类型，U是数组大小
    template<typename T, int U>
    auto DotProduct(T* array1, T* array2)
    {
        T dpResult = T{}; // 和值，零初始化
        for (int i = 0; i < U; ++i)
        {
            dpResult += array1[i] * array2[i];
        }
        return dpResult;
    }
    
    void func()
    {
        int a[] = {1, 2, 3};
        int b[] = {4, 5, 6};
        
        int result = DotProduct<int, 3>(a, b);
        
        std::cout << result << std::endl;
        // 32
    }
}
```

代码改进，使用inline

从编译出来的汇编代码可以看到，没有inline之前，是通过调用DotProduct<int, 3>实现数组a和数组b的点积运算

改成inline后，没有了对DotProduct的调用，而是直接替换成函数本体，这样就导致编译器也不再需要取实例化DotProduct<int, 3>

当然因为存在for循环，所以在汇编中会有jge和jmp的判断和跳转的字样，这些判断和调整必然也会对程序运行效率存在一定的影响

```c++
namespace _nmsp3
{
    // T 是数组元素类型，U是数组大小
    template<typename T, int U>
    inline auto DotProduct(T* array1, T* array2)
    {
        T dpResult = T{}; // 和值，零初始化
        for (int i = 0; i < U; ++i)
        {
            dpResult += array1[i] * array2[i];
        }
        return dpResult;
    }
    
    void func()
    {
        int a[] = {1, 2, 3};
        int b[] = {4, 5, 6};
        
        int result = DotProduct<int, 3>(a, b);
        
        std::cout << result << std::endl;
        // 32
    }
}
```

## 混合元编程计算点积

使用混合元编程计算点积
出发点就是，如果能做到不用循环，还能做到相加，这样必然效率会有提升
即

> result += array1[0] * array2[0]
> result += array1[1] * array2[1]
> result += array1[2] * array2[2]

### 范例演示

```c++
namespace _nmsp4
{
    // 泛化版本
    template<typename T, int U> // T:元素类型， U是数组大小
    struct DotProduct
    {
        static T result(const T* a, const T* b)
        {
            return (*a) * (*b) + DotProduct<T, U-1>::result(a + 1, b + 1);
        }
    };
    
    // 特化版本（递归调用出口）
    template<typename T> // T:元素类型， U是数组大小
    struct DotProduct<T, 0>
    {
        static T result(const T* a, const T* b)
        {
            // 返回0，用T{},零初始化返回 0 
            return T{};
        }
    };
    
    void func()
    {
        int a[] = {1, 2, 3};
        int b[] = {4, 5, 6};
        
        int result = DotProduct<int, 3>::result(a, b);
        
        std::cout << result << std::endl;
    }
}
```

可以预想到，这种递归模板，最终会实例化出

> DotProduct<int, 3>
> DotProduct<int, 2>
> DotProduct<int, 1>
> DotProduct<int, 0>

这4个类，然后编译器会按顺序计算出点积值，即

> DotProduct<int, 3>::result(a, b) = 
> (*a) * (*b) + DotProduct<int, 2>::result(a +1, b + 1) =
> (*a) * (*b) + (*(a+1)) * (*(b+1)) + DotProduct<int, 1>::result(a +2, b + 2) =
> (*a) * (*b) + (*(a+1)) * (*(b+1)) + (*(a+2)) * (*(b+2)) + DotProduct<int, 0>::result(a + 3, b + 3) =
> (*a) * (*b) + (*(a+1)) * (*(b+1)) + (*(a+2)) * (*(b+2)) + 0

### c++编译的两个阶段

因为有混合元编程的存在，我们可以把c++的编译过程分为2个阶段：前期阶段 和 后期阶段

前期阶段，此阶段的c++编译器实际充当的解释器的角色，直接针对程序员开发的c++源码（元编程代码）进行解释性执行
这一阶段的工作成果，就是会产生一系列的c++代码（所以元编程才会被看做是运行期c++代码生成器）

后期阶段，此阶段c++编译器恢复了大家比较熟悉的c++编译器本来应该具备的功能--- 针对前期阶段产生的结果代码进行编译链接
最终生成可执行代码

### 范例演示的扩展--代码的智能化产生与膨胀

如果你想用模板，但是又不想 让自己最终的可执行文件变的很大， 有2种方式:

(1)你的模板类不会生成很多模板实例，这样写成模板类还有意义吗?

(2)你的模板类的代码量或是函数个数很少，你可以仿照ATL的方式把模板无关的东西逐层剥离。

现在的编译器都会尝试合并template里的代码段的。只是大量用模板，编译速度慢不少，但是代码膨胀带来的是更多的功能与更高的执行效率。

### 类模板实例化的进一步观察

实现一个类模板，用于获得两个数中的小的那个值（当然，这里写的很啰嗦，只是为了演示模板实例化）

```c++
namespace _nmsp1
{
    // 泛化版本
    template<int x_v, int y_v>
    struct InstantialtionObServe
    {
        static const int value = (x_v > y_v) ? InstantialtionObServe<x_v - 1, y_v>::value : InstantialtionObServe<x_v, x_v>::value;
    };
    
    // 特化版本
    template<int v>
    struct InstantialtionObServe<v, v>
    {
        static const int value = v;
    };
    
    void func()
    {
        std::cout << InstantialtionObServe<9, 2>::value << std::endl;
        // 2
    }
}
```

元编程时，要小心使用条件运算符（？：）,因为不管条件是否成立，所涉及到的类都可能会被实例化出来

那既然条件运算符有这种弊端，有没有什么改进方法呢？

std::conditional， 他能根据一个布尔值，在两者之间选择一个
std::conditional比条件运算符（？：）更有优势

```c++
namespace _nmsp2
{
    // 泛化版本
    template<int x_v, int y_v>
    struct InstantialtionObServe
    {
        using TmpType = typename std::conditional<(x_v > y_v), InstantialtionObServe<x_v - 1, y_v>, InstantialtionObServe<x_v, x_v>>::type;
        // 注意这段代码只是为类型取一个别名，这段代码并不会导致c++编译器实例化出任何代码
        
        static const int value = TmpType::value;
        // 正真导致实例化的是这行代码，因为这行代码用到了上面定义的别名
    };
    
    // 特化版本
    template<int v>
    struct InstantialtionObServe<v, v>
    {
        static const int value = v;
    };
    
    void func()
    {
        std::cout << InstantialtionObServe<900, 2>::value << std::endl;
        // 2
        // 而且看到，这种写法，能支持的判断范围更大，上面的写法中因为不管你条件成立与否，
        // 都会进行实例化，这就导致编译器因为实例化限制（递归深度限制），能支持到的实例化不是很多，
        // 但是这种写法只会去实例化条件成立的，所以能支持的判断数肉眼可见的提升
    }
}
```



### inline静态成员变量