# 混合元编程

- 1）程序员写出一段元编程代码
- 2）编译器根据这段代码编译（生成）一段新代码，实现程序真正功能的是这段生成的新代码
- 3）编译器会对这段新代码进行编译，产生出最终的可执行程序

混合元编程可以看成是运行时c++代码生成器


## 常规的计算点积范例

- 1）数组a有3个元素， a[0], a[1], a[2], 值分别是 1， 2， 3
- 2）数组b有3个元素， b[0], b[1], b[2], 值分别是 4， 5， 6

a和b的点积就是， a[0] * b[0] + a[1] * b[1] + a[2] * b[2] = 32

```c++
namespace _nmsp2
{
    // T 是数组元素类型，U是数组大小
    template<typename T, int U>
    auto DotProduct(T* array1, T* array2)
    {
        T dpResult = T{}; // 和值，零初始化
        for (int i = 0; i < U; ++i)
        {
            dpResult += array1[i] * array2[i];
        }
        return dpResult;
    }
    
    void func()
    {
        int a[] = {1, 2, 3};
        int b[] = {4, 5, 6};
        
        int result = DotProduct<int, 3>(a, b);
        
        std::cout << result << std::endl;
        // 32
    }
}
```

代码改进，使用inline

从编译出来的汇编代码可以看到，没有inline之前，是通过调用DotProduct<int, 3>实现数组a和数组b的点积运算

改成inline后，没有了对DotProduct的调用，而是直接替换成函数本体，这样就导致编译器也不再需要取实例化DotProduct<int, 3>

当然因为存在for循环，所以在汇编中会有jge和jmp的判断和跳转的字样，这些判断和调整必然也会对程序运行效率存在一定的影响

```c++
namespace _nmsp3
{
    // T 是数组元素类型，U是数组大小
    template<typename T, int U>
    inline auto DotProduct(T* array1, T* array2)
    {
        T dpResult = T{}; // 和值，零初始化
        for (int i = 0; i < U; ++i)
        {
            dpResult += array1[i] * array2[i];
        }
        return dpResult;
    }
    
    void func()
    {
        int a[] = {1, 2, 3};
        int b[] = {4, 5, 6};
        
        int result = DotProduct<int, 3>(a, b);
        
        std::cout << result << std::endl;
        // 32
    }
}
```

## 混合元编程计算点积

使用混合元编程计算点积
出发点就是，如果能做到不用循环，还能做到相加，这样必然效率会有提升
即

> result += array1[0] * array2[0]
> result += array1[1] * array2[1]
> result += array1[2] * array2[2]

```c++
namespace _nmsp4
{
    // 泛化版本
    template<typename T, int U> // T:元素类型， U是数组大小
    struct DotProduct
    {
        static T result(const T* a, const T* b)
        {
            return (*a) * (*b) + DotProduct<T, U-1>::result(a + 1, b + 1);
        }
    };
    
    // 特化版本（递归调用出口）
    template<typename T> // T:元素类型， U是数组大小
    struct DotProduct<T, 0>
    {
        static T result(const T* a, const T* b)
        {
            // 返回0，用T{},零初始化返回 0 
            return T{};
        }
    };
    
    void func()
    {
        int a[] = {1, 2, 3};
        int b[] = {4, 5, 6};
        
        int result = DotProduct<int, 3>::result(a, b);
        
        std::cout << result << std::endl;
    }
}
```



### 范例演示

### c++编译的两个阶段

### 范例演示的扩展--代码的智能化产生与膨胀

### 类模板实例化的进一步观察

### inline静态成员变量